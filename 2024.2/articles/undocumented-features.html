<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Using Undocumented Features | Remora.Discord </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Using Undocumented Features | Remora.Discord ">
    <meta name="generator" content="docfx ">
  
    <link rel="shortcut icon" href="../images/1f988.svg">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
    <link rel="stylesheet" href="../styles/colors.css">
    <link rel="stylesheet" href="../styles/discord.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    <meta property="docfx:version" content="2024.2">
    <meta property="docfx:versionsrel" content="../../versions.json">
  
  
  
  </head>

  <body>
        <div class="top-navbar">

            <a class="burger-icon" onclick="toggleMenu()">
                <svg name="Hamburger" style="vertical-align: middle;" width="24" height="24" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" clip-rule="evenodd" d="M20 6H4V9H20V6ZM4 10.999H20V13.999H4V10.999ZM4 15.999H20V18.999H4V15.999Z"></path></svg>
            </a>


            <a class="brand" href="../index.html">
              <img src="../images/1f988.svg" alt="Remora.Discord" class="logomark">
              <span class="brand-title">Remora.Discord</span>
            </a>
        </div>

        <div class="body-content">

            <div id="blackout" class="blackout" onclick="toggleMenu()"></div>

            <nav id="sidebar" role="navigation">

                <div class="sidebar">
                    

                    <div>
                      <div class="mobile-hide">

                        <a class="brand" href="../index.html">
                          <img src="../images/1f988.svg" alt="Remora.Discord" class="logomark">
                          <span class="brand-title">Remora.Discord</span>
                        </a>                      </div>

                        <div id="versionbar"></div>
                        <div class="sidebar-item-separator"></div>


                      <div id="navbar">
                      </div>
                    </div>


                    <div class="sidebar-item-separator"></div>


                        <div id="sidetoggle">
                          <div id="sidetoc"></div>
                        </div>

                </div>

                <div class="footer">
  
  <span>Generated by <strong>DocFX</strong></span>
                </div>
            </nav>

            <main class="main-panel">


                <div role="main" class="main-panel-content hide-when-search">


                        <div class="subnav navbar navbar-default">
                          <div class="container hide-when-search" id="breadcrumb">
                            <ul class="breadcrumb">
                              <li></li>
                            </ul>
                          </div>
                        </div>

                    <article class="content wrap" id="_content" data-uid="">
<h1 id="using-undocumented-features">Using Undocumented Features</h1>

<p>The unfortunate reality of using the Discord API is that, while the online
documentation is extensive, it is not exhaustive. Discord often exposes
undocumented fields, endpoints, and data structures that may still be of use to
developers, even though they aren't ready, finished, or thoroughly documented.</p>
<p>Remora has a few ways for you to access these undocumented features, but beware!
As with any unstable API surface, things may break from one second to the next
without warning.</p>
<h2 id="data">Data</h2>
<h3 id="undocumented-fields">Undocumented Fields</h3>
<p>If you want to implement access to an undocumented field on an existing type,
create a new record that inherits from the existing model, and register it with
the DI system.</p>
<pre><code class="lang-cs">public record SomeExistingDataWithMoreStuff(int Existing, int Additional) 
    : SomeExistingData(Existing);
</code></pre>
<p>Note that to <em>override</em> an existing data model, you have to register it <em>after</em>
Remora's own setup.</p>
<pre><code class="lang-cs">// Add the base types from Remora
var serviceCollection = new ServiceCollection()
    .AddDiscordGateway(_ =&gt; botToken)
    .AddDiscordCommands(true);

// Add overriding data models
serviceCollection.Configure&lt;JsonSerializerOptions&gt;
(
    options =&gt; 
    {
        options.AddDataObjectConverter&lt;ISomeExistingData, SomeExistingDataWithMoreStuff&gt;();
    }
);
</code></pre>
<p>You can also specialize various parts of the data model when registering it,
such as property names (which is useful for C#-ifying naming of boolean
properties) and their type converters.</p>
<h3 id="undocumented-data-structures">Undocumented Data Structures</h3>
<p>Any undocumented data structure can be added to Remora externally, and treated
as if it were bundled with Remora using the existing DI system.</p>
<p>Suppose we have the following undocumented data:</p>
<pre><code class="lang-json">{
  &quot;some_name&quot;: 10
}
</code></pre>
<p>You would then model and register the following structures.</p>
<pre><code class="lang-cs">public interface ISomeData
{
    int SomeName { get; }
}

public record SomeData(int SomeName) : ISomeData;
</code></pre>
<p>Registration is the same as if you were implementing an undocumented field, but
you may register it before Remora's own types.</p>
<h2 id="gateway">Gateway</h2>
<h3 id="undocumented-events--commands">Undocumented Events &amp; Commands</h3>
<p>Any undocumented event or command can be added to Remora the same way as you
would add a new undocumented data structure. However, you only need to model the
data portion of the event or command.</p>
<p>Suppose we have the following undocumented event:</p>
<pre><code class="lang-json">{
  &quot;t&quot;: &quot;SOME_UNDOCUMENTED_EVENT&quot;,
  &quot;s&quot;: 4,
  &quot;op&quot;: 0,
  &quot;d&quot;: {
      &quot;some_name&quot;: 10
  }
}
</code></pre>
<p>You would then model and register the following event data. Note that event
names <em>must</em> match the interface name you create - that is, if the event is
named <code>SOME_EVENT</code>, your interface must be named <code>ISomeEvent</code>.</p>
<pre><code class="lang-cs">public interface ISomeUndocumentedEvent
{
    int SomeName { get; }
}

public record SomeUndocumentedEvent(int SomeName) : ISomeUndocumentedEvent;
</code></pre>
<h2 id="rest">REST</h2>
<p>Features that relate to the REST API is customized through one of two methods.</p>
<p>The first is the <code>RestHttpClient</code> type, which can be accessed and used
through DI. It's a named, transient <code>HttpClient</code>, which takes care of minutia
like authorization headers and respecting rate limits for you. You would mainly
use this type when you want to make requests to completely undocumented
endpoints, or to take complete control over a call to a known endpoint.</p>
<pre><code class="lang-cs">public class Somewhere
{
    private readonly RestHttpClient _client;

    public Somewhere(RestHttpClient client)
    {
        _client = client;
    }
}
</code></pre>
<p>The second is through the concrete implementations of the API interfaces, which
allow you to perform smaller tweaks or changes to existing API methods, such as
adding headers or JSON payload fields.</p>
<h3 id="undocumented-endpoints">Undocumented Endpoints</h3>
<p>To access an undocumented endpoint, you may use the <code>RestHttpClient</code> directly
to make any kind of HTTP request, similar to how you might use a normal
<code>HttpClient</code>. All requests made by this client are prepended with the most
recently versioned Discord API base endpoint, which typically looks like this:
<code>https://discord.com/api/v9/</code>. Therefore, you should only use relative endpoints
when making requests.</p>
<pre><code class="lang-cs">var result = await _client.GetAsync&lt;ISomeData&gt;($&quot;somewhere/{someId}/data&quot;);
</code></pre>
<p>Refer to the existing implementations of endpoints in the library for examples
of how to add JSON parameters, HTTP headers, or similar data.</p>
<h3 id="undocumented-parameters--headers">Undocumented Parameters &amp; Headers</h3>
<p>If you want to provide additional data to an existing endpoint, such as JSON
parameters, HTTP headers, or query string parameters, you can easily add
customizations to <em>all</em> requests made by the API within a particular scope. This
feature is only available to you when you inject the concrete implementation of
an API category, however, and not through the interface.</p>
<p>This means that if you want to, for example, send an additional JSON field when
sending a message, you would need to inject <code>DiscordRestChannelAPI</code> and not
<code>IDiscordRestChannelAPI</code>.</p>
<p>This is useful when an endpoint is discovered to allow undocumented parameters,
or metadata headers such as <code>X-Audit-Log-Reason</code>.</p>
<p>Once you have the concrete implementation available to you, creating a
customization is simple.</p>
<pre><code class="lang-cs">using (_ = _api.WithCustomization(r =&gt; r.WithJson(json =&gt; json.WriteString(&quot;name&quot;, &quot;value&quot;))))
{
    // This call will now have &quot;name&quot;: &quot;value&quot; in its JSON payload, in addition
    // to the normal data.
    var result = await _api.SomeEndpointAsync();
}

// This call will not have any additional data
var result = await _api.SomeEndpointAsync();
</code></pre>
<p>The customization uses the same types and logic for configuring a request's
parameters, methods, and headers as implementing a custom endpoint, so if you
learn one you should have no trouble using the other.</p>
<p>Multiple customizations may be in effect at the same time, and will be applied
in the order you create them. A customization is removed from the client when it
is disposed.</p>

</article>
              
                </div>
            </main>
        </div>


        <script src="https://code.jquery.com/jquery-3.5.1.min.js" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
        <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js" integrity="sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI" crossorigin="anonymous"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
        <script type="text/javascript" src="../styles/jquery.twbsPagination.js"></script>
        <script type="text/javascript" src="../styles/url.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js"></script>
        <script type="text/javascript" src="../styles/docfx.js"></script>
        <script type="text/javascript" src="../styles/main.js"></script>
        <script type="module">
            import mermaid from 'https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.0.2/mermaid.esm.min.mjs';
            mermaid.initialize({
                startOnLoad: false,
                theme: "dark",
                flowchart: {
                    curve: "stepAfter"
                }
            });
            mermaid.run({
                querySelector: ".lang-mermaid",
                suppressErrors: true,
            });
        </script>

    </body>

</html>
