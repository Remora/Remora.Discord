//
//  Sodium.cs
//
//  Author:
//       Jarl Gullberg <jarl.gullberg@gmail.com>
//
//  Copyright (c) 2017 Jarl Gullberg
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU Lesser General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//

using System;
using System.Runtime.InteropServices;
using JetBrains.Annotations;
using Remora.Discord.Voice.Errors;
using Remora.Results;

#pragma warning disable SA1300 // Element should begin with upper-case letter

namespace Remora.Discord.Voice.Interop.Sodium
{
    /// <summary>
    /// Represents an interface to the native libsodium library.
    /// </summary>
    public sealed unsafe partial class Sodium
    {
        private const string SodiumLibraryName = "libsodium";

        /// <summary>
        /// Initializes the sodium library. Subsequent invocations simply return a success code immediately.
        /// </summary>
        /// <returns>A value indicating the result of the operation.</returns>
        [DllImport(SodiumLibraryName, CallingConvention = CallingConvention.Cdecl)]
        private static extern int sodium_init();

        /// <summary>
        /// Gets the version of the underlying sodium library.
        /// </summary>
        /// <returns>A pointer to the version string.</returns>
        [DllImport(SodiumLibraryName, CallingConvention = CallingConvention.Cdecl)]
        private static extern byte* sodium_version_string();

        /// <summary>
        /// Gets the size of the key expected by the xsalsa20_poly1305 algorithm.
        /// </summary>
        /// <returns>The key size in bytes.</returns>
        [DllImport(SodiumLibraryName, CallingConvention = CallingConvention.Cdecl)]
        private static extern uint crypto_secretbox_xsalsa20poly1305_keybytes();

        /// <summary>
        /// Gets the size of the nonce expected by the xsalsa20_poly1305 algorithm.
        /// </summary>
        /// <returns>The nonce size in bytes.</returns>
        [DllImport(SodiumLibraryName, CallingConvention = CallingConvention.Cdecl)]
        private static extern uint crypto_secretbox_xsalsa20poly1305_noncebytes();

        /// <summary>
        /// Gets the size of the MAC generated by the xsalsa20_poly1305 algorithm.
        /// </summary>
        /// <returns>The MAC size in bytes.</returns>
        [DllImport(SodiumLibraryName, CallingConvention = CallingConvention.Cdecl)]
        private static extern uint crypto_secretbox_xsalsa20poly1305_macbytes();

        /// <summary>
        /// Encrypts a messages using the xsalsa20_poly1305 algorithm.
        /// </summary>
        /// <param name="output">Output buffer for the encrypted data.</param>
        /// <param name="message">The message to encrypt.</param>
        /// <param name="messageLength">The length of the message.</param>
        /// <param name="nonce">The nonce to use.</param>
        /// <param name="key">The key to use.</param>
        /// <returns>Zero on success, else -1.</returns>
        [DllImport(SodiumLibraryName, CallingConvention = CallingConvention.Cdecl)]
        private static extern int crypto_secretbox_easy(byte* output, byte* message, ulong messageLength, byte* nonce, byte* key);

        /// <summary>
        /// Fills <paramref name="size"/> random bytes into the buffer.
        /// </summary>
        /// <param name="buffer">The buffer to fill.</param>
        /// <param name="size">The number of random bytes to produce.</param>
        [DllImport(SodiumLibraryName, CallingConvention = CallingConvention.Cdecl)]
        private static extern void randombytes_buf(byte* buffer, int size);
    }

    [PublicAPI]
    public sealed unsafe partial class Sodium
    {
        private const int SodiumInitFailedResult = -1;

        private static ReadOnlyMemory<byte> _keyBytes;

        /// <summary>
        /// Gets the version of the underlying sodium library.
        /// </summary>
        public static readonly string? Version = Marshal.PtrToStringAnsi((IntPtr)sodium_version_string());

        /// <summary>
        /// Gets the size of the key expected by the xsalsa20_poly1305 algorithm.
        /// </summary>
        public static readonly uint KeySize = crypto_secretbox_xsalsa20poly1305_keybytes();

        /// <summary>
        /// Gets the size of nonce expected by the xsalsa20_poly1305 algorithm.
        /// </summary>
        public static readonly uint NonceSize = crypto_secretbox_xsalsa20poly1305_noncebytes();

        /// <summary>
        /// Gets the size of MAC generated by the xsalsa20_poly1305 algorithm.
        /// </summary>
        public static readonly uint MacSize = crypto_secretbox_xsalsa20poly1305_macbytes();

        private Sodium(ReadOnlyMemory<byte> keyBytes)
        {
            _keyBytes = keyBytes;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Sodium"/> class.
        /// </summary>
        /// <param name="keyBytes">The key bytes to encode data with.</param>
        /// <returns>The created <see cref="Sodium"/> instance, or an error if the initialization failed.</returns>
        public static Result<Sodium> Create(ReadOnlyMemory<byte> keyBytes)
        {
            if (keyBytes.Length != KeySize)
            {
                return new ArgumentOutOfRangeError(nameof(keyBytes), "Key must have a size of " + KeySize);
            }

            if (sodium_init() == SodiumInitFailedResult)
            {
                return new SodiumError("Failed to initialise the sodium library");
            }

            return new Sodium(keyBytes);
        }

        /// <summary>
        /// Fills the given buffer with randomly generated bytes.
        /// </summary>
        /// <param name="buffer">The buffer to fill.</param>
        public static void GenerateRandomBytes(Span<byte> buffer)
        {
            fixed (byte* bufferPtr = buffer)
            {
                randombytes_buf(bufferPtr, buffer.Length);
            }
        }

        /// <summary>
        /// Encrypts a message using the xsalsa20_poly1305 algorithm.
        /// </summary>
        /// <param name="message">The message to encrypt.</param>
        /// <param name="outputBuffer">Output buffer for the encrypted data.</param>
        /// <param name="nonce">The nonce to use.</param>
        /// <returns>A value indicating if the encryption was successful.</returns>
        public Result Encrypt(ReadOnlySpan<byte> message, Span<byte> outputBuffer, ReadOnlySpan<byte> nonce)
        {
            if (nonce.Length != NonceSize)
            {
                return new ArgumentOutOfRangeError(nameof(nonce), "The nonce must have a size of " + NonceSize);
            }

            if (outputBuffer.Length != MacSize + message.Length)
            {
                return new ArgumentOutOfRangeError("Output buffer length should be the sum of the sodium MAC size and the message length.");
            }

            bool result = false;

            fixed (byte* messagePtr = message)
            {
                fixed (byte* outputPtr = outputBuffer)
                {
                    fixed (byte* noncePtr = nonce)
                    {
                        fixed (byte* keyPtr = _keyBytes.Span)
                        {
                            result = crypto_secretbox_easy(outputPtr, messagePtr, (ulong)message.Length, noncePtr, keyPtr) == 0;
                        }
                    }
                }
            }

            return !result
                ? new SodiumError("Failed to encrypt.")
                : Result.FromSuccess();
        }
    }
}
