<!DOCTYPE html><html><head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=Edge">
        <meta name="description">
        <meta name="keywords" content="static content generator,static site generator,static site,HTML,web development,.NET,C#,Razor,Markdown,YAML">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="shortcut icon" href="/Remora.Discord/assets/img/favicon.ico" type="image/x-icon">
        <link rel="icon" href="/Remora.Discord/assets/img/favicon.ico" type="image/x-icon">
        <title>Remora.Discord Documentation - Getting Started</title>
        <link href="/Remora.Discord/assets/css/highlight.css" rel="stylesheet">
        <link href="/Remora.Discord/assets/css/bootstrap/bootstrap.css" rel="stylesheet">
        <link href="/Remora.Discord/assets/css/adminlte/AdminLTE.css" rel="stylesheet">
        <link href="/Remora.Discord/assets/css/theme/theme.css" rel="stylesheet">
        <link href="//fonts.googleapis.com/css?family=Roboto+Mono:400,700|Roboto:400,400i,700,700i" rel="stylesheet">
        <link href="/Remora.Discord/assets/css/font-awesome.min.css" rel="stylesheet" type="text/css">
        <link href="/Remora.Discord/assets/css/override.css" rel="stylesheet">
        <script src="/Remora.Discord/assets/js/jquery-2.2.3.min.js"></script>
        <script src="/Remora.Discord/assets/js/bootstrap.min.js"></script>        
        <script src="/Remora.Discord/assets/js/app.min.js"></script>         
        <script src="/Remora.Discord/assets/js/highlight.pack.js"></script>   
        <script src="/Remora.Discord/assets/js/jquery.slimscroll.min.js"></script>
        <script src="/Remora.Discord/assets/js/jquery.sticky-kit.min.js"></script>
        <script src="/Remora.Discord/assets/js/mermaid.min.js"></script>
        <script src="/Remora.Discord/assets/js/svg-pan-zoom.min.js"></script>
        <!--[if lt IE 9]>
        <script src="/Remora.Discord/assets/js/html5shiv.min.js"></script>
        <script src="/Remora.Discord/assets/js/respond.min.js"></script>
        <![endif]-->  

        
    </head>
    <body class="hold-transition wyam layout-boxed  ">    
        <div class="top-banner"></div>
        <div class="wrapper with-container">
            <!-- Header -->
            <header class="main-header">   
                     
                <a href="/Remora.Discord/" class="logo">
                            <span>Remora.Discord Documentation</span>
                </a>   
                         
                <nav class="navbar navbar-static-top" role="navigation">
                    <!-- Sidebar toggle button-->
                        <a href="#" class="sidebar-toggle visible-xs-block" data-toggle="offcanvas" role="button">
                            <span class="sr-only">Toggle side menu</span>
                            <i class="fa fa-chevron-circle-right"></i>
                        </a>
                                        
                    <div class="navbar-header">
                        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse">
                            <span class="sr-only">Toggle side menu</span>
                            <i class="fa fa-chevron-circle-down"></i>
                        </button>
                    </div>
            
                    <!-- Collect the nav links, forms, and other content for toggling -->
                    <div class="collapse navbar-collapse pull-left" id="navbar-collapse">
                        <ul class="nav navbar-nav">                            
                                    <li class="active"><a href="/Remora.Discord/guides">Guides</a></li>
        <li><a href="/Remora.Discord/info">Info</a></li>
        <li><a href="/Remora.Discord/api">API</a></li>
 
                        </ul>       
                    </div>
                    <!-- /.navbar-collapse -->
                
                    <!-- Navbar Right Menu -->
                </nav>
            </header>
            
            <!-- Left side column. contains the logo and sidebar -->
            <aside class="main-sidebar ">
                <section class="infobar" data-spy="affix" data-offset-top="60" data-offset-bottom="200"> 
                    	
    <div id="infobar-headings"></div>

                </section>
                <section class="sidebar">    
                                     
                    

                    <ul class="sidebar-menu">
                        

                <li class="selected"><a href="/Remora.Discord/guides/getting-started">Getting Started</a></li>

                    </ul>
                            
                </section>                
            </aside>
            
            <!-- Content Wrapper. Contains page content -->
            <div class="content-wrapper">
                



		<section class="content-header">
			<h1>Getting Started</h1>
		</section>
	<section class="content">
		<p>This guide will walk you through setting up a basic ping-pong bot with
Remora.Discord, showing you the basic concepts of the library. At the end of the
tutorial, you should have the tools you need to start diving into more complex
bots and use cases.</p>
<p>There'll be some assumptions made in this guide related to commands and terminal
environments - primarily, a system with <code>bash</code> is assumed, but the commands
should be easily transferable to any shell language.</p>
<h2 id="creating-your-project">Creating your project</h2>
<p>First of all, ensure that you have version 5.0 of the .NET Core SDK installed.
If you don't have it yet, you can follow the instructions on <a href="https://docs.microsoft.com/en-us/dotnet/core/install/">this</a> page for
your system.</p>
<p>Next up, we'll create a simple console program that'll serve as the host for our
bot - you can do this in many different ways, but we'll stick to the terminal in
this guide. Feel free to use your favourite IDE instead, such as
<a href="https://www.jetbrains.com/rider/">JetBrains Rider</a> or <a href="https://code.visualstudio.com/">VS Code</a>.</p>
<pre><code class="language-bash">dotnet new console -n "PingPong"
cd PingPong
dotnet add package Remora.Discord -v "3.0.33"
</code></pre>
<p>In the commands above, replace <code>-v "3.0.33"</code> with the release you'd like to
install (or remove it altogether if you'd like to use the latest stable
release).</p>
<p>Opening up the <code>Program.cs</code> file, we can start to set up our environment.</p>
<p>Since we're writing a bot that's going to respond to a simple command, we need a
connection to Discord's realtime gateway. This is facilitated through the
<code><a href="/Remora.Discord/api/Remora.Discord.Gateway/DiscordGatewayClient">DiscordGatewayClient</a></code> class, as well as a bot account you'll need to create
with Discord themselves. From this account, you'll get a bot token, which the
gateway client will use to authenticate with the gateway.</p>
<p>For now, we'll do everything in our <code>Main</code> method, but as your bot grows, it's
almost a certainty that you'll need to expand out to more types, files, and
namespaces.</p>
<p>The first thing we'll do is create a <code>CancellationTokenSource</code>. This is going to
be our primary way of gracefully shutting down our bot, letting it notify the
Discord gateway that it's disconnecting, and allowing it to shut down any
<code>Responders</code> that are currently running (more on those later).</p>
<p>For simplicity's sake, we'll set up our program to respond to CTRL+C at the
command line, and terminate the gateway client if it catches that keypress.</p>
<pre><code class="language-csharp">static async Task Main(string[] args)
{
    var cancellationSource = new CancellationTokenSource();

    Console.CancelKeyPress += (sender, eventArgs) =&gt;
    {
        eventArgs.Cancel = true;
        cancellationSource.Cancel();
    };
}
</code></pre>
<p>After this, we'll set up a service provider. Remora.Discord uses <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-3.1">dependency
injection</a> throughout its codebase, and it's through these systems we
register and access various types and services from the library.</p>
<pre><code class="language-csharp">var botToken = "YOUR_TOKEN_HERE";

var services = new ServiceCollection()
    .AddDiscordGateway(() =&gt; botToken)
    .BuildServiceProvider();
</code></pre>
<p>A quick note here - <em>do not</em> place your bot token in the source code of your
program when you write your real bot. It's a massive security risk, and is only
done here for the sake of this guide. You should store your token outside of the
program in some kind of database or file (appsettings, plaintext file, etc) that
is not directly accessible from your source code.</p>
<p>With that out of the way, have a look at the snippet above. We register a set of
services from Remora.Discord via a convenience extension method called
<code>AddDiscordGateway</code> - this method adds everything you need to start using the
gateway client. It takes a single parameter, which is a function that returns
your bot token. In our case, that just references our local variable where we've
stored the token.</p>
<p>To get a gateway client instance, we can then request it from the service
provider we've created.</p>
<pre><code class="language-csharp">var gatewayClient = services.GetRequiredService&lt;<a href="/Remora.Discord/api/Remora.Discord.Gateway/DiscordGatewayClient">DiscordGatewayClient</a>&gt;();
</code></pre>
<p>At this point, the gateway client is fully functional, but has not connected to
the gateway yet. To do this, we call the <code>RunAsync</code> method, and pass in the
cancellation token from the source we created earlier.</p>
<pre><code class="language-csharp">var runResult = await gatewayClient.RunAsync(cancellationSource.Token);
</code></pre>
<p>Most things that deal with networking or external services have a fair chance to
fail, halt, or otherwise not complete perfectly. Remora.Discord is written to
try its damnedest to never let a potential runtime error bring down your
program, which means that any operation that could conceivably run into an issue
like that returns an <code>IResult</code> (or a type that implements that interface). This
is a safe and predictable wrapper around either a failed or a successful
operation - in the case of a failure, it'll contain a human-readable message
that should help you understand what went wrong.</p>
<p>In the case of <code>RunAsync</code>, this is a <code>GatewayConnectionResult</code>, which can
contain some additional information about what caused the gateway client to stop
running.</p>
<p>Let's implement some error handling next.</p>
<pre><code class="language-csharp">if (!runResult.IsSuccess)
{
    switch (runResult.Error)
    {
        case ExceptionError exe:
        {
            log.LogError
            (
                exe.Exception,
                "Exception during gateway connection: {ExceptionMessage}",
                exe.Message
            );

            break;
        }
        case GatewayWebSocketError:
        case GatewayDiscordError:
        {
            log.LogError("Gateway error: {Message}", runResult.Unwrap().Message);
            break;
        }
        default:
        {
            log.LogError("Unknown error: {Message}", runResult.Unwrap().Message);
            break;
        }
    }
}

Console.WriteLine("Bye bye");
</code></pre>
<p>Under normal circumstances, the gateway client will gracefully handle errors and
try to keep you connected to the gateway (either by reconnecting and resuming,
or by creating a new session) until you ask it to turn off via the cancellation
token provided to <code>RunAsync</code>. If <code>runResult</code> isn't successful, you can be fairly
certain something outside of normal operation has happened - either it's a
programming error on the part of the library, or something that's made the
gateway unable or unwilling to continue trying to connect to the gateway. In
general, if the error is recoverable, Remora.Discord will try to fulfill your
requests until it can no longer justify any further efforts (often, this means
some sort of timeout or max number of retries).</p>
<p>At this point, you should be able to run the program and see your bot come
online in Discord. Hooray! If you want to see an overview of what the gateway
client is doing, you can configure a logging provider in the service provider -
<code>AddConsole</code> from <code>Microsoft.Extensions.Logging.Console</code> is usually a good
choice for simple projects. Adding logging will produce some output similar to
the following.</p>
<pre><code>info: Remora.Discord.Gateway.DiscordGatewayClient[0]
      Retrieving gateway endpoint...
info: Remora.Discord.Gateway.DiscordGatewayClient[0]
      Connecting to the gateway...
info: Remora.Discord.Gateway.DiscordGatewayClient[0]
      Creating a new session...
info: Remora.Discord.Gateway.DiscordGatewayClient[0]
      Connected.
</code></pre>
<p>Now, in its current state, our bot doesn't do much of anything. Sure, it runs
and connects, but that's no fun! Let's add a simple <code>Responder</code> that can - as
the name suggests - respond to events from Discord's gateway.</p>
<p>Responders are defined as any class that implements one or more <code>IResponder&lt;T&gt;</code>
interfaces, where <code>T</code> is an event from the Discord gateway. If the gateway
client gets an event that one or more responders are interested it, it will
instantiate them and dispatch it to the responders, letting them handle it on
their own.</p>
<p>A responder can take as little or as much time as it needs to handle an event
without affecting the gateway - they're entirely separate systems, save for the
fact that they also share the cancellation token with the gateway client.</p>
<p>Let's create our responder now.</p>
<pre><code class="language-csharp"> public class PingPongResponder : IResponder&lt;<a href="/Remora.Discord/api/Remora.Discord.API.Abstractions.Gateway.Events/IMessageCreate">IMessageCreate</a>&gt;
{
}
</code></pre>
<p>This responder will only respond to <code><a href="/Remora.Discord/api/Remora.Discord.API.Abstractions.Gateway.Events/IMessageCreate">IMessageCreate</a></code> events from the gateway -
that is, events that contain information about a message someone has posted, be
they user or bot. You can implement as many <code>IResponder&lt;T&gt;</code> interfaces as you
like, and the responder will react to them all.</p>
<p>One thing to note is that a responder is not persistent - that is, it is not the
same instance that responds to the events, even events of the same type. The
responder is what's called a <code>Scoped</code> service in DI parlance, and each event
from the gateway carries its own scope. This means that if you want to retain
information between events, you'll need to outsource that to some other type -
most likely registered as a <code>Singleton</code>, or <code>Scoped</code> in an outer scope.</p>
<p>The <code>IResponder&lt;T&gt;</code> interface is relatively simple, only defining a single
method.</p>
<pre><code class="language-csharp">public async Task&lt;Result&gt; RespondAsync
(
    <a href="/Remora.Discord/api/Remora.Discord.API.Abstractions.Gateway.Events/IMessageCreate">IMessageCreate</a> gatewayEvent,
    CancellationToken ct = default
)
{
}
</code></pre>
<p>Here, we can see the event coming in, and a type that implements <code>IResult</code>
rearing its head again. Responders, much like any user-facing operation, can
fail! Maybe it can't find some resource it needs, or maybe something couldn't be
parsed properly - anything that results in the responder being unable to finish
its task should result in a failed result being returned.</p>
<p>We can also see that the cancellation token from earlier is available to us -
this is the same token that we passed to <code>RunAsync</code>, and we should respect it.
If cancellation has been requested, we should bail out with a failed result as
soon as we can.</p>
<p>Now, our command will be <em>very</em> simple, and won't really be much more than a
direct match against the message contents, but it gets the point across. In the
future, we'll have a proper command framework available, but that's outside of
the scope of this quickstart.</p>
<pre><code class="language-csharp">if (gatewayEvent.Content != "!ping")
{
    return Result.FromSuccess();
}

var embed = new Embed(Description: "Pong!", Colour: Color.LawnGreen);
</code></pre>
<p>If the message isn't something we're interested in, we return a successful
result - after all, if we just don't care, it's hardly a failure of our own
code. If the message does match, however, we'd like to send an embed back to the
user with a pong to show that we got their ping. <code>new</code>'ing up an embed is simple
enough, but we need to send it back to the user in the same channel, too.</p>
<p>This is done through Discord's REST API, which we also have access to. This,
however, we need to explicitly request through - you guessed it - dependency
injection. Let's jump out of the response method for a moment, and implement a
constructor that takes the API we're interested in.</p>
<pre><code class="language-csharp">private readonly <a href="/Remora.Discord/api/Remora.Discord.API.Abstractions.Rest/IDiscordRestChannelAPI">IDiscordRestChannelAPI</a> _channelAPI;

public PingPongResponder(IDiscordRestChannelAPI channelAPI)
{
    _channelAPI = channelAPI;
}
</code></pre>
<p>Every section of Discord's REST API is available in this form, as an interface
defining the various endpoints. Back in our responder method, we can now use the
channel API.</p>
<pre><code class="language-csharp">if (gatewayEvent.Content != "!ping")
{
    return Result.FromSuccess();
}

var embed = new Embed(Description: "Pong!", Colour: Color.LawnGreen);
var replyResult = await _channelAPI.CreateMessageAsync
(
    gatewayEvent.ChannelID,
    embeds: new[] { embed },
    ct: ct
);

return !replyResult.IsSuccess
    ? Result.FromError(replyResult)
    : Result.FromSuccess();
</code></pre>
<p>The <code>CreateMessageAsync</code> method takes a lot of various parameters, but we're
really only interested in the embed and channel parameters right now -
therefore, we can skip over the other optional parameters and just pass in the
ones we care about.</p>
<p>With that done, our responder is implemented and ready to go! There's only one
final thing to do before we can run our bot and see it in action - we need to
make it available to the gateway client via - say it with me - dependency
injection!</p>
<p>Back in our <code>Main</code> method, where we configure our services, we'll make a small
addition.</p>
<pre><code class="language-csharp">var responderService = new ResponderService();
var services = new ServiceCollection()
    .AddDiscordGateway(() =&gt; botToken)
    .AddResponder&lt;PingPongResponder&gt;(responderService)
    .BuildServiceProvider();
</code></pre>
<p>And that's it! The <code>AddResponder&lt;T&gt;</code> method registers the responder as a scoped
service for all of the <code>IResponder&lt;T&gt;</code> interfaces it implements. The responder
service is a supporting type for event dispatching, and keeps track of which
responders are registered for which events.</p>
<p>Now, running your bot, going into Discord, and running your command should net
you the following.</p>
<p><img src="images/ping-pong.png" class="img-fluid" alt="Ping, Pong!"></p>
<p>Congratulations! You've written your first bot using Remora.Discord, and
familiarized yourself with the basic concepts of the library. Hopefully, this
should set you on the right path, and give you the tools you need to create
great bots with the library.</p>
<p>If you're interested in looking at some bots authored by the community or by the
library author(s), have a look at the <a href="https://github.com/Nihlus/Remora.Discord/tree/master/Samples">samples</a> in the repository. If you
have any questions, please don't hesitate to ask, or open an issue in the main
repo.</p>
<p>Good luck!</p>

	</section>
                
            </div>           
            
            <!-- Footer -->
            <footer class="main-footer">
            </footer>
            
        </div>
        <div class="wrapper bottom-wrapper">
            <footer class="bottom-footer">
                Generated by <a href="https://wyam.io">Wyam</a>
            </footer>
        </div>
        <a href="javascript:" id="return-to-top"><i class="fa fa-chevron-up"></i></a>
        
        <script>           
            // Close the sidebar if we select an anchor link
            $(".main-sidebar a[href^='#']:not('.expand')").click(function(){
                $(document.body).removeClass('sidebar-open');
            });
            
            $(document).ready(function() {
                mermaid.initialize(
                {
                    flowchart:
                    {
                        useMaxWidth: false
                    },
					startOnLoad: false,
					cloneCssStyles: false
                });     
                mermaid.init(undefined, ".mermaid");

                // Remove the max-width setting that Mermaid sets
                var mermaidSvg = $('.mermaid svg');
                mermaidSvg.addClass('img-responsive');
                mermaidSvg.css('max-width', '');

                // Make it scrollable
				var target = document.querySelector(".mermaid svg");
				if(target !== null)
				{
					var panZoom = window.panZoom = svgPanZoom(target, {
						zoomEnabled: true,
						controlIconsEnabled: true,
						fit: true,
						center: true,
                        maxZoom: 20,
                        zoomScaleSensitivity: 0.6
					});			                          

                    // Do the reset once right away to fit the diagram
                    panZoom.resize();
                    panZoom.fit();
                    panZoom.center();
                    
                    $(window).resize(function(){
                        panZoom.resize();
                        panZoom.fit();
                        panZoom.center();
                    });
				}
                
                $('pre code').each(function(i, block) {
                    hljs.highlightBlock(block);
                });  
            });

            hljs.initHighlightingOnLoad();

            // Back to top
            $(window).scroll(function() {
                if ($(this).scrollTop() >= 200) {        // If page is scrolled more than 50px
                    $('#return-to-top').fadeIn(1000);    // Fade in the arrow
                } else {
                    $('#return-to-top').fadeOut(1000);   // Else fade out the arrow
                }
            });
            $('#return-to-top').click(function() {      // When arrow is clicked
                $('body,html').animate({
                    scrollTop : 0                       // Scroll to top of body
                }, 500);
            });
        </script>
    
</body></html>